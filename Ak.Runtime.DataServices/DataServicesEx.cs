using System;
using System.Configuration;
using System.Globalization;
using System.Runtime.Remoting.Messaging;
using NegotiationsPlatform.DataServices.Client.Channel;
using NegotiationsPlatform.Logger;
using NegotiationsPlatform.RunTime.DataBase;
using NegotiationsPlatform.RunTime.Wcf;


namespace NegotiationsPlatform.DataServices.Client
{
    // This code was generated by the Exception Handling WCF Proxy Generator add-in for Visual Studio 2008
    // For updates and to view the supporting webcast go to http://wcfproxygenerator.codeplex.com
    // Also go to http://wcfguidanceforwpf.codeplex.com for related whitepapers, webcasts and code samples

    using System;
    using System.ServiceModel;
    using System.Threading;
    using System.ServiceModel.Channels;
    using System.ServiceModel.Description;
    using System.Reflection;
    using System.Collections.Generic;
    using System.Linq;

    public abstract class DataServicesEx<TIService> : ProxyBase<TIService> where TIService : class
    {
        internal static string _internalEndPoint;
        private readonly Binding _binding;
        private readonly EndpointAddress _endpointAddress;
        private readonly string _endPointConfigurationName;
        private static readonly object SyncLock = new object();
        

        public DataServicesEx()
        {}

        public DataServicesEx(string endPoint) : base(endPoint)
        {
            _endPointConfigurationName = endPoint;
        }
        public DataServicesEx(string bindingConfigurationName, string remoteAddress)
        {
            //_binding = RunTime.Config.Read.ResolveBinding(bindingConfigurationName); 
            //_endpointAddress = new EndpointAddress(new Uri(string.Format(remoteAddress, _internalEndPoint)));
            //Initialize(_binding, _endpointAddress);
        }
        public DataServicesEx(Binding bindingConfiguration, EndpointAddress endpointAddress)
        {
            _binding = bindingConfiguration;
            _endpointAddress = endpointAddress;
            _internalEndPoint = endpointAddress.ToString();
            //Initialize(_binding, _endpointAddress);
        }
        
        public TIService Channel
        {
            get
            {
                if (InnerChannelFactory == null)
                {
                    lock (SyncLock)
                    {
                        if (InnerChannelFactory == null)
                        {
                          //  if(string.IsNullOrEmpty(_internalEndPoint))
                                Initialize(_endPointConfigurationName);
                          //  else
                            //    Initialize(_binding, _endpointAddress);
                        }
                    }
                }
                
                /* open channel */
                Open();
                //#if DEBUG return InnerChannel; #endif
                return InnerProxy;
            }
            protected set { if (value == null) throw new ArgumentNullException(nameof(value)); }
        }

        protected static TIService PrivateChannel { get; set; }
       
    }

    public abstract class ProxyBase<T> : ICommunicationObject, IDisposable
             where T : class
    {
        private static readonly Log Logger = Log.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);
        // state
        private bool IsOpened { get; set; }
        public bool IsDisposed { get; protected set; }

        // lock
        private readonly object m_channelLock = new object();
        protected bool _isInitialized = false;
        private bool _isProxyCreated = false;
        private readonly ManualResetEvent _mProxyRecreationLock = new ManualResetEvent(true);
        protected int MProxyRecreationLockWait = 1000;

        // channel
        private T m_channel = default(T);
        // proxy
        private T m_proxy = default(T);

        protected virtual ChannelFactory<T> InnerChannelFactory { get; set; }
        protected static Action InnerRegisterCallbacks { get; set; }

        #region Constructors

        protected ProxyBase()
        {
            InnerChannelFactory = null;
        }

        protected ProxyBase(string endpointConfigurationName) 
            : this()
        {
            //Initialize(endpointConfigurationName);
        }

        protected virtual void Initialize(string endpointConfigurationName)
        {
            if (this._isInitialized) throw new InvalidOperationException("Object already initialized.");
            this._isInitialized = true;
            Logger.Info(string.Format("DataServicesProxyBase:CreateChannelFactory:Initialize EndPoint {0}", endpointConfigurationName));
            
            InnerChannelFactory = new ChannelFactory<T>(endpointConfigurationName);
            this.m_channel = null;
        }
      
        protected virtual void Initialize(string endpointConfigurationName, string remoteAddress)
        {
            if (this._isInitialized) throw new InvalidOperationException("Object already initialized.");
            this._isInitialized = true;

            InnerChannelFactory = new ChannelFactory<T>(endpointConfigurationName, new EndpointAddress(remoteAddress));
            this.m_channel = null;
        }

        //protected DataServicesProxyBase(Binding binding, EndpointAddress remoteAddress)
        //{
        //    InnerChannelFactory = null;
        //    Initialize(binding, remoteAddress);
        //}

        protected virtual void Initialize(Binding binding, EndpointAddress remoteAddress)
        {
            if (this._isInitialized) throw new InvalidOperationException("Object already initialized.");
            this._isInitialized = true;

            InnerChannelFactory = new ChannelFactory<T>(binding, remoteAddress);
            this.m_channel = null;
        }

        #endregion

        #region Proxy creation

        public event EventHandler AfterRecreateProxy;

        protected virtual void CreateProxy()
        {

            lock (this.m_channelLock)
            {
                if (this._isProxyCreated) throw new InvalidOperationException("Proxy already created.");
                CreateInnerChannel();
                this._isProxyCreated = true;

            }
        }

        protected virtual void RecreateProxy()
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                CreateInnerChannel();

                if (AfterRecreateProxy != null)
                    AfterRecreateProxy(this, null);
            }
        }

        private void CreateInnerChannel()
        {
            lock (this.m_channelLock)
            {
                if (InnerChannelFactory == null)
                    throw new InvalidOperationException("Proxy invalid. This occurs when you use the default constructor.");

                Logger.Info(string.Format("DataServicesProxyBase:CreateProxy:CreateInnerChannel: {0}", typeof(T)));
         
                m_channel = InnerChannelFactory.CreateChannel();

                var extendedProxy = new ProxyWrapper<T>(typeof(T), this);
                m_proxy = (T)extendedProxy.GetTransparentProxy();

                ICommunicationObject co = m_channel as ICommunicationObject;
                co.Faulted += InnerChannel_Faulted;
                co.Closed += InnerChannel_Closed;
                co.Closing += InnerChannel_Closing;
                co.Opened += InnerChannel_Opened;
                co.Opening += InnerChannel_Opening;

                /* Execute Register Callback Notification */
                InnerRegisterCallbacks?.Invoke();

            }
        }
        #endregion

        #region Communication events

        protected void InnerChannel_Opening(object sender, EventArgs e)
        {
            lock (m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                Logger.Info(string.Format("DataServicesProxyBase:InnerChannel_Opening: {0}", typeof(T)));

                if (this.Opening != null)
                    this.Opening(sender, e);
            }
        }

        private void InnerChannel_Opened(object sender, EventArgs e)
        {
            lock (m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                Logger.Info(string.Format("DataServicesProxyBase:InnerChannel_Opened: {0}", typeof(T)));

                if (this.Opened != null)
                    this.Opened(sender, e);
            }
        }


        void InnerChannel_Closing(object sender, EventArgs e)
        {
            lock (m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                Logger.Warn(string.Format("DataServicesProxyBase:InnerChannel_Closing: {0}", typeof(T)));

                if (this.Closing != null)
                    this.Closing(sender, e);
            }
        }
        private void InnerChannel_Closed(object sender, EventArgs e)
        {
            lock (m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                Logger.Warn(string.Format("DataServicesProxyBase:InnerChannel_Closed: {0}", typeof(T)));
                try
                {
                    this._mProxyRecreationLock.Reset(); // will stop other threads from trying to Invoke() while recreating the proxy

                    if (this.Closed != null)
                        this.Closed(sender, e);

                    OnClosed();
                }
                finally
                {
                    this._mProxyRecreationLock.Set(); // will stop other threads from trying to Invoke() while recreating the proxy
                }

            }

        }
        protected virtual void OnClosed()
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                this.Abort();
                RecreateProxy();

            }
        }


        private void InnerChannel_Faulted(object sender, EventArgs e)
        {
            lock (m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                Logger.Error(string.Format("DataServicesProxyBase:InnerChannel_Faulted: {0}", typeof(T)));
         
                try
                {
                    this._mProxyRecreationLock.Reset(); // will stop other threads from trying to Invoke() while recreating the proxy

                    if (this.Faulted != null)
                        this.Faulted(sender, e);

                    OnFaulted();
                }
                finally
                {
                    this._mProxyRecreationLock.Set(); // will stop other threads from trying to Invoke() while recreating the proxy
                }
            }

        }
        protected virtual void OnFaulted()
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                this.Abort();
                RecreateProxy();
            }
        }

        #endregion

        # region Channel Properties
        public T InnerChannel
        {
            get
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                return (T)m_channel;
            }
        }

        public T InnerProxy
        {
            get
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                return (T)m_proxy;
            }
        }

        

        public ClientCredentials ClientCredentials
        {
            get
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                return InnerChannelFactory.Credentials;
            }
        }

        public ServiceEndpoint Endpoint
        {
            get
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                return InnerChannelFactory.Endpoint;
            }
        }

        public CommunicationState State
        {
            get
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                IChannel channel = (IChannel)m_channel;
                if (channel == null)
                    return CommunicationState.Created;

                return channel.State;
            }
        }

        #endregion

        #region ICommunicationObject Members

        public event EventHandler Closed;
        public event EventHandler Closing;
        public event EventHandler Faulted;
        public event EventHandler Opened;
        public event EventHandler Opening;

        public void Abort()
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                ICommunicationObject co = (ICommunicationObject)m_channel;
                co.Closed -= new EventHandler(this.InnerChannel_Closed);
                co.Closing -= new EventHandler(this.InnerChannel_Closing);
                co.Faulted -= new EventHandler(this.InnerChannel_Faulted);
                co.Opened -= new EventHandler(this.InnerChannel_Opened);
                co.Opening -= new EventHandler(this.InnerChannel_Opening);
                co.Abort();
            }
        }

        public void Open(TimeSpan timeout)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                if (!this.IsOpened)
                {
                    EnsureProxy();
                    ((ICommunicationObject)m_channel).Open(timeout);
                    this.IsOpened = true;
                }
            }
        }

        public void Open()
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");

                if (!this.IsOpened)
                {
                    EnsureProxy();

                    ((ICommunicationObject)m_channel).Open();
                    Logger.Info(string.Format("DataServicesProxyBase:CreateChannel:Open: : {0}", typeof(T)));
                    this.IsOpened = true;
                }
            }
        }

        public void Close(TimeSpan timeout)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                ((ICommunicationObject)m_channel).Close(timeout);
            }
        }

        public void Close()
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                Logger.Warn(string.Format("DataServicesProxyBase:Close: {0}", typeof(T)));
                ((ICommunicationObject)m_channel).Close();
                ((ICommunicationObject)m_channel).Close();
            }
        }

        public IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                return ((ICommunicationObject)m_channel).BeginClose(timeout, callback, state);
            }
        }

        public IAsyncResult BeginClose(AsyncCallback callback, object state)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                return ((ICommunicationObject)m_channel).BeginClose(callback, state);
            }
        }

        public IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                return ((ICommunicationObject)m_channel).BeginClose(timeout, callback, state);
            }
        }

        public IAsyncResult BeginOpen(AsyncCallback callback, object state)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                return ((ICommunicationObject)m_channel).BeginOpen(callback, state);
            }
        }

        public void EndClose(IAsyncResult result)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                ((ICommunicationObject)m_channel).EndClose(result);
            }
        }

        public void EndOpen(IAsyncResult result)
        {
            lock (this.m_channelLock)
            {
                if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
                ((ICommunicationObject)m_channel).EndOpen(result);
            }
        }


        #endregion

        #region IDisposable Members

        public void Dispose()
        {
            lock (m_channelLock)
            {
                Logger.Warn(string.Format("DataServicesProxyBase:Dispose: {0}", typeof(T)));
                Cleanup();
                this.IsDisposed = true;
            }
        }

        protected virtual void Cleanup()
        {
            try
            {
                ICommunicationObject co = (ICommunicationObject)m_channel;
                co.Closed -= InnerChannel_Closed;
                co.Closing -= InnerChannel_Closing;
                co.Faulted -= InnerChannel_Faulted;
                co.Opened -= InnerChannel_Opened;
                co.Opening -= InnerChannel_Opening;
                co.Close();
            }
            catch
            {
                try
                {
                    ICommunicationObject co = (ICommunicationObject)m_channel;
                    co.Abort();
                }
                catch { }
            }

            try
            {
                InnerChannelFactory.Close();
            }
            catch
            {
                try
                {
                    InnerChannelFactory.Abort();
                }
                catch { }
            }

        }

        #endregion

        #region Invoke

        public delegate void RetryInvokeHandler(out Message unreadMessage);
        public event RetryInvokeHandler RetryInvoke;

        protected void Invoke(string operationName, params object[] parameters)
        {
            if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
            this.Open();

            MethodInfo methodInfo = GetMethod(operationName);

            try
            {
                // manual reset event here, turn it on when faulted
                // other threads will queue, and get a successful Invoke() once proxy is recreated
                this._mProxyRecreationLock.WaitOne(this.MProxyRecreationLockWait); // if this takes longer than 1 second we have bigger problems
                methodInfo.Invoke(m_channel, parameters);
            }
            catch (TargetInvocationException targetEx) // Invoke() always throws this type
            {
                CommunicationException commEx = targetEx.InnerException as CommunicationException;
                if (commEx == null)
                {
                    throw targetEx.InnerException; // not a communication exception, throw it
                }

                FaultException faultEx = commEx as FaultException;
                if (faultEx != null)
                {
                    throw targetEx.InnerException; // the service threw a fault, throw it
                }

                try
                {
                    // manual reset event here, turn it on when faulted
                    // other threads will queue, and get a successful Invoke() once proxy is recreated
                    this._mProxyRecreationLock.WaitOne(this.MProxyRecreationLockWait); // if this takes longer than 1 second we have bigger problems

                    // if it is a Message type it won't work, must fire RetryInvoke() and hopefully derived class will supply the original
                    // message to send again...
                    if (parameters.Length == 1 && parameters[0] is Message)
                    {
                        Message unreadMessage;
                        RetryInvoke(out unreadMessage);
                        methodInfo.Invoke(m_channel, new object[] { unreadMessage }); // a communication exception, retry once
                    }
                    else
                        methodInfo.Invoke(m_channel, parameters); // a communication exception, retry once
                }
                catch (TargetInvocationException targetEx2)
                {
                    throw targetEx2.InnerException; // still failed, throw it
                }
            }
        }

        public TResult Invoke<TResult>(IMessage message)
        {
            var methodCall = message as IMethodCallMessage;
            var methodInfo = methodCall.MethodBase as MethodInfo;
            return Invoke<TResult>(methodInfo, methodCall.InArgs);
        }

        protected TResult Invoke<TResult>(string operationName, params object[] parameters)
        {
            MethodInfo methodInfo = GetMethod(operationName);
            return Invoke<TResult>(methodInfo, parameters);
        }

        protected TResult Invoke<TResult>(MethodInfo methodInfo, params object[] parameters)
        {

            if (this.IsDisposed) throw new InvalidOperationException("Cannot use disposed object.");
            this.Open();

            TResult result = default(TResult);

            try
            {
                // manual reset event here, turn it on when faulted
                // other threads will queue, and get a successful Invoke() once proxy is recreated
                this._mProxyRecreationLock.WaitOne(this.MProxyRecreationLockWait); // if this takes longer than 1 second we have bigger problems
                result = (TResult)methodInfo.Invoke(m_channel, parameters);
            }
            catch (TargetInvocationException targetEx) // Invoke() always throws this type
            {
                var targetex = targetEx.InnerException;

                Logger.Fatal(string.Format("TargetInvocationException: Typeof={0} MethodInfo={1}, {2}", typeof(T), methodInfo.Name, parameters), targetEx);               

                CommunicationException commEx = targetEx.InnerException as CommunicationException;
                if (commEx == null)
                {
                    Logger.Fatal(string.Format("CommunicationException: {0}, {1}", typeof(T), targetEx.InnerException));
                   throw targetEx.InnerException; // not a communication exception, throw it
                }

                FaultException faultEx = commEx as FaultException;
                if (faultEx != null)
                {
                    Logger.Fatal(string.Format("FaultException: {0}, {1}", typeof(T), targetEx.InnerException));
                    throw targetEx.InnerException; // the service threw a fault, throw it
                }
                

                // a communication exception, retry once
                try
                {
                    // manual reset event here, turn it on when faulted
                    // other threads will queue, and get a successful Invoke() once proxy is recreated
                    this._mProxyRecreationLock.WaitOne(this.MProxyRecreationLockWait); // if this takes longer than 1 second we have bigger problems

                    // if it is a Message type it won't work, must fire RetryInvoke() and hopefully derived class will supply the original
                    // message to send again...
                    if (parameters.Length == 1 && parameters[0] is Message)
                    {
                        Message unreadMessage;
                        RetryInvoke(out unreadMessage);
                        result = (TResult)methodInfo.Invoke(m_channel, new object[] { unreadMessage }); // communication exception, retry once
                    }
                    else
                        result = (TResult)methodInfo.Invoke(m_channel, parameters); // communication exception, retry once

                }
                catch (TargetInvocationException targetEx2)
                {
                    Logger.Fatal(string.Format("TargetInvocationException: {0}, ", typeof(T)), targetEx2);                  

                    throw targetEx2.InnerException; // still failed, throw it
                }
            }
            //((T)m_proxy).
            //this.Close();
            return result;
        }

        internal MethodInfo GetMethod(string operationName)
        {
            Type t = typeof(T);

            HashSet<MethodInfo> methods = new HashSet<MethodInfo>();
            GetMethodsRecursive(t, BindingFlags.Public | BindingFlags.Instance, ref methods);

            var result = from m in methods
                         where m.Name == operationName
                         select m;

            if (result.Count() == 0)
                throw new InvalidOperationException(String.Format("Unable to invoke method {0}. Method does not exist on contract {1}.", operationName, t.ToString()));

            if (result.Count() > 1)
                throw new InvalidOperationException(String.Format("Unable to invoke method {0}. More than one method is defined on contract {1} by the same name. Overloads not supported by CachedProxyBase.", operationName, t.ToString()));

            return result.First();
        }

        private void GetMethodsRecursive(Type t, BindingFlags flags, ref HashSet<MethodInfo> methods)
        {
            MethodInfo[] children = t.GetMethods(flags);
            methods.UnionWith(children);
            foreach (Type contract in t.GetInterfaces())
            {
                GetMethodsRecursive(contract, flags, ref methods);
            }
        }

        private void EnsureProxy()
        {
            lock (this.m_channelLock)
            {
                if (!this._isProxyCreated)
                {
                    this.CreateProxy();
                }
            }
        }

        #endregion

    }
}

